#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrbook
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
theorems-ams-extended
enumitem
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Degc Language
\end_layout

\begin_layout Author
Jonathan Clark
\end_layout

\begin_layout Chapter
Language Specification
\end_layout

\begin_layout Section
Lexical Grammar
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
Lexical grammar is similar to the 
\emph on
Python
\emph default
 language.
\end_layout

\begin_layout Standard
The Degc tokenizer always returns the longest possible token which can be
 produced from the input.
 Tokens are delimited by non-matching characters and by whitespace.
 An unrecognized character or sequence is treated as an error.
\end_layout

\begin_layout Standard
In Degc, whitespace is syntactically significant.
 Four (
\begin_inset Formula $4$
\end_inset

) spaces are used to indent blocks, and other whitespace characters are
 ignored.
 Spaces are also ignored inside parenthesized 
\begin_inset Formula $(,)$
\end_inset

 and bracketed 
\begin_inset Formula $[,]$
\end_inset

 code.
\end_layout

\begin_layout Standard
Line comments are indicated with a hash # symbol.
 All input from the hash sign to the end of the current line is ignored.
\end_layout

\begin_layout Subsection
Identifiers
\end_layout

\begin_layout Standard
Types and functions are designated by a string identifier.
 Valid identifiers may begin with an underscore, or any upper- or lower-case
 English letter.
 Identifiers may not begin with numbers, but numbers are permitted in the
 remainder of the identifier.
\end_layout

\begin_layout Standard
Identifiers which begin with a number, or contain any symbols other than
 English letters, numbers, and underscores, are invalid.
\end_layout

\begin_layout Subsection
Literals
\end_layout

\begin_layout Standard
Degc includes the Boolean literal values 
\emph on
true
\emph default
 and 
\emph on
false
\emph default
.
\end_layout

\begin_layout Standard
Numeric literals denote fractional decimal numbers, and may contain any
 Arabic number from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $9$
\end_inset

, and optionally a single decimal 
\begin_inset Formula $.$
\end_inset

 which must be followed by additional numbers.
 Degc supports fixed-precision numbers with 
\begin_inset Formula $\varepsilon=0.0001$
\end_inset

.
\end_layout

\begin_layout Subsection
Keywords and Punctuators
\end_layout

\begin_layout Standard
The Degc lexicon contains the following keywords: 
\emph on
all, and, any, assert, as, best, by, either, else, embed, enum, exists,
 extends, for, from, function, if, import, intersect, in, limit, module,
 not, or, panic, program, record, setminus, set, take, union, with.
\end_layout

\begin_layout Standard
The Degc lexicon also contains the following punctuators: 
\emph on
@ : , .
 -> + - * / < <= > >= = != ( ) [ ] { } |
\end_layout

\begin_layout Section
Syntactic Grammar
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
Degc is a declarative language for describing academic programs.
 As such, Degc programs are written to model the given problem, rather than
 written to execute specific computations.
\end_layout

\begin_layout Standard
Degc programs operate over an input 
\emph on
ontology
\emph default
 - a set of facts, which are described using records.
 Degc programs do not have direct access to the contents of records.
 Instead, Degc programs contain assertions about the ontology.
 A Degc program evaluates 
\emph on
true
\emph default
 when all of its assertions are true, and 
\emph on
false
\emph default
 otherwise.
\end_layout

\begin_layout Subsection
Declarations
\end_layout

\begin_layout Subsubsection
Records
\end_layout

\begin_layout Standard
A record is a quantum of the input ontology.
 Records contain relevant facts, such as courses or certifications taken,
 student status, etc.
\end_layout

\begin_layout Standard
A record may optionally have one 
\emph on
quantity
\emph default
 field.
 A record type must have a quantity field to use 
\emph on
take 
\emph default
and 
\emph on
limit 
\emph default
statements.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
record TakenCourse:
\end_layout

\begin_layout LyX-Code
    Faculty faculty
\end_layout

\begin_layout LyX-Code
    Subject subject
\end_layout

\begin_layout LyX-Code
    number level
\end_layout

\begin_layout LyX-Code
    quantity credits
\end_layout

\begin_layout Subsubsection
Enumerations
\end_layout

\begin_layout Standard
Enumerations are a list of options.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
enum Subject:
\end_layout

\begin_layout LyX-Code
    CMPUT
\end_layout

\begin_layout LyX-Code
    MATH
\end_layout

\begin_layout LyX-Code
    ENGL
\end_layout

\begin_layout LyX-Code
    PHIL
\end_layout

\begin_layout Subsubsection
Functions
\end_layout

\begin_layout Standard
Degc contains an embedded functional programming language which can be accessed
 by writing functions.
 Degc supports higher-order functions, but not lexical closures.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
function SubjectLevelCourse(Subject sub, number lev) -> set(TakenCourse):
\end_layout

\begin_layout LyX-Code
    { TakenCourse | subject = sub and level >= lev and level < (lev + 100)
 }
\end_layout

\begin_layout Subsubsection
Programs
\end_layout

\begin_layout Standard
Degc programs describe statements about the ontology.
 Programs may inherit from other programs.
 Programs may be parameterized, but are restricted to enumeration arguments.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
program ExampleProgram(Subject majorSubject):
\end_layout

\begin_layout LyX-Code
    take 6 in { TakenCourse | subject = majorSubject }
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Subsubsection
Overview
\end_layout

\begin_layout Standard
Deg expressions are similar to those in other languages.
 As is typical, function calls have the highest precedence, followed by
 member access, unary operators (arithmetic and boolean negation), multiplicatio
n, addition, relations, equality, logical and, and logical or.
 A higher precedence may be imposed with parentheses.
\end_layout

\begin_layout Subsubsection
Logical and Arithmetic
\end_layout

\begin_layout Standard
Degc supports the usual arithmetic operators for number types: 
\emph on
+,-,*,/
\emph default
.
\end_layout

\begin_layout Standard
Degc also supports the following logical operations: 
\emph on
and, or, not
\emph default
.
\end_layout

\begin_layout Subsubsection
Relational
\end_layout

\begin_layout Standard
Degc supports the following relational operators: 
\emph on
=,!=,>,>=,<,<=
\emph default
.
\end_layout

\begin_layout Standard
Nominal types - enumerations and booleans - support the identity relations.
\end_layout

\begin_layout Standard
The ordinal numeric type supports all relational operators.
\end_layout

\begin_layout Subsubsection
Set
\end_layout

\begin_layout Standard
Set expressions are used to describe a portion of the ontology.
 They are constructed using a typical set builder notation.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
{ TakenCourse }
\end_layout

\begin_layout Standard
This code describes a set of all records with the type 
\emph on
TakenCourse
\emph default
.
\end_layout

\begin_layout LyX-Code
{ TakenCourse | subject = Subject.CMPUT and level < 200 }
\end_layout

\begin_layout Standard
This code describes a set of all records with the type 
\family typewriter
\emph on
TakenCourse
\emph default
, a subject of 
\emph on
CMPUT
\emph default
, and a level which is below 
\begin_inset Formula $200$
\end_inset

.
\end_layout

\begin_layout Standard
It must be possible to represent the constructed set as a union of orthogonal
 ranges.
 As a result, set clause relations must each depend on a single record member,
 and that member must be isolated on a single side of the relational operator.
\end_layout

\begin_layout Standard
Sets support the 
\emph on
exists, union, intersect, 
\emph default
and 
\emph on
setminus
\emph default
 operators.
 The 
\emph on
exists
\emph default
 operator returns true if and only if there is at least one record matching
 the input set.
 The other operators function as expected.
\end_layout

\begin_layout Subsubsection
Panic
\end_layout

\begin_layout Standard
Degc supports a rudimentary exception mechanism.
 Panic will immediately cause the executing program to terminate with a
 result of 
\emph on
false
\emph default
.
\end_layout

\begin_layout Subsection
Statements
\end_layout

\begin_layout Subsubsection
Overview
\end_layout

\begin_layout Standard
Program statements are used to describe facts about the ontology.
 In the following, an asterisk (*) indicates that the statement type is
 planned but not currently supported by the reference implementation.
\end_layout

\begin_layout Subsubsection
Assertions
\end_layout

\begin_layout Standard
Assertions execute a boolean expression.
 If the expression evaluates as 
\emph on
false
\emph default
, the current execution is rejected.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
assert exists { RoyalConservatoryPiano | grade >= 6 }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsubsection
Embed
\end_layout

\begin_layout Standard
Embed statements include, in-line, the contents of another program.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
embed ComputingScienceMajor
\end_layout

\begin_layout Standard
Parameterized programs may also be embedded with included arguments.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
embed MajorProgramMap(majorSubject) with (minorSubject,)
\end_layout

\begin_layout Standard
The embed keyword may also be used to enclose program statements in a nested
 block:
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
take 6 in { TakenCourse | subject = majorSubject }
\end_layout

\begin_layout LyX-Code
embed:
\end_layout

\begin_layout LyX-Code
    assert exists { StudentRegistered }
\end_layout

\begin_layout LyX-Code
    take 6 in { TakenCourse | subject = minorSubject }
\end_layout

\begin_layout LyX-Code
take 3 in { TakenCourse }
\end_layout

\begin_layout Subsubsection
Disjunction
\end_layout

\begin_layout Standard
Disjunctions are used to indicate a non-discriminated branch.
 Program execution is successful if at least one branch may be taken.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
either:
\end_layout

\begin_layout LyX-Code
    assert exists { TakenCourse | subject = Subject.MUS and level = 110 }
\end_layout

\begin_layout LyX-Code
or:
\end_layout

\begin_layout LyX-Code
    assert exists { PianoExemptionExam | grade >= 0.8 }
\end_layout

\begin_layout LyX-Code
or:
\end_layout

\begin_layout LyX-Code
    assert exists { RoyalConservatoryPiano | grade >= 6 }
\end_layout

\begin_layout Subsubsection
For All*
\end_layout

\begin_layout Standard
For All loops execute the statement body for each record in the matching
 set.
 This allows programs to make assertions about all records in the ontology.
\end_layout

\begin_layout Standard
For All loops may not contain 
\emph on
take
\emph default
 or 
\emph on
limit
\emph default
 statements.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
for all course in { TakenCourse | subject = Subject.CMPUT }:
\end_layout

\begin_layout LyX-Code
    assert course.grade >= 2.7
\end_layout

\begin_layout Subsubsection
For Any*
\end_layout

\begin_layout Standard
For Any loops execute the statement body for any one, arbitrarily-chosen
 record in the ontology.
\end_layout

\begin_layout Standard
For Any loops may not contain 
\emph on
take
\emph default
 or 
\emph on
limit
\emph default
 statements.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
for any status in { RegistrationStatus }:
\end_layout

\begin_layout LyX-Code
    assert status.registered
\end_layout

\begin_layout Subsubsection
For Best*
\end_layout

\begin_layout Standard
For Best loops execute the statement body for the best matching record,
 where the best record is identified with an order predicate.
\end_layout

\begin_layout Standard
For Best loops may not contain 
\emph on
take
\emph default
 or 
\emph on
limit
\emph default
 statements.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
function HighestGrade(TakenCourse a, TakenCourse b)->bool:
\end_layout

\begin_layout LyX-Code
    a.grade >= b.grade
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
for best course by HighestGrade in { TakenCourse }:
\end_layout

\begin_layout LyX-Code
    assert course.grade >= 4.0
\end_layout

\begin_layout Subsubsection
Conditional
\end_layout

\begin_layout Standard
Conditional statements are used to indicate a discriminated branch.
 Conditional statements are used to branch program execution predicated
 upon the value of a boolean expression.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
if exists { RoyalConservatoryPiano | grade >= 6 }:
\end_layout

\begin_layout LyX-Code
    assert not exists { PianoExemptionExam }
\end_layout

\begin_layout LyX-Code
else:
\end_layout

\begin_layout LyX-Code
    assert exists { PianoExemptionExam }
\end_layout

\begin_layout Subsubsection
Take
\end_layout

\begin_layout Standard
Take statements are used to allocate a specified quantity from a set.
 Once taken, the quantity cannot be used to fulfill another 
\emph on
take
\emph default
 requirement.
\end_layout

\begin_layout Standard
For example, an academic program may require 
\begin_inset Formula $6$
\end_inset

 credits from art courses and 
\begin_inset Formula $3$
\end_inset

 additional credits in free options.
 Although art credits may be applied toward the free option requirement,
 art credits may not simultaneously be applied to both requirements.
\end_layout

\begin_layout LyX-Code
take 6 in { TakenCourse | faculty = Faculty.AR }
\end_layout

\begin_layout LyX-Code
take 3 in { TakenCourse }
\end_layout

\begin_layout Standard
In this example, the student always requires at least 
\begin_inset Formula $9$
\end_inset

 credits in taken courses.
\end_layout

\begin_layout Subsubsection
Limit
\end_layout

\begin_layout Standard
Limit statements are used to constrain the quantity which may be taken from
 a set.
\end_layout

\begin_layout Standard
For example, a typical academic program will apply a restriction on the
 number of introductory-level courses which may be applied to a program
 of study.
 Limit statements allow these types of requirements to be imposed while
 still maximizing the assignment of credits.
\end_layout

\begin_layout LyX-Code
limit 42 in { TakenCourse | level < 200 }
\end_layout

\begin_layout Standard
Due to the algorithm used for solving programs, limit sets must either be
 point-wise disjoint or a sub/super-set.
 Compliant Degc compilers must produce an error when a program contains
 limit statements which do not satisfy this restriction.
\end_layout

\begin_layout Chapter
Execution Model
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
Degc uses a hybrid execution model which combines an integer program with
 assertions defined using a programming language.
\end_layout

\begin_layout Standard
Due to the specific form of integer programs written in Degc, it is possible
 to describe the integer program portions as an instance of network max-flow.
 This correspondence allows a larger amount of preprocessing and a guaranteed
 polynomial execution time.
 The disadvantage to this approach is a greater demand for storage space.
 Since branches may produce significantly different networks, each possible
 branch and combination of program parameters must be enumerated into a
 separate network.
\end_layout

\begin_layout Standard
The accompanying bytecode program serves to prune the set of feasible networks
 which must be tested.
 Any branch which contains a failing assertion is flagged as infeasible,
 and it is excluded during program execution.
\end_layout

\begin_layout Standard
Programs are thus executed in three major stages:
\end_layout

\begin_layout Enumerate
The fully specified program is selected based on the input parameters.
\end_layout

\begin_layout Enumerate
The bytecode program is executed, masking impossible branches.
\end_layout

\begin_layout Enumerate
The max-flow is computed for each possible branch.
\end_layout

\begin_deeper
\begin_layout Enumerate
Credit quantities are computed from the ontology and assigned to the network
 inputs.
\end_layout

\begin_layout Enumerate
The max-flow is computed with the Edmonds-Karp algorithm.
\end_layout

\begin_layout Enumerate
If the max-flow is sufficient, the program has been satisfied and returns
 immediately.
\end_layout

\end_deeper
\begin_layout Section
Integer Program - Network Correspondence
\end_layout

\begin_layout Note
The 
\emph on
take
\emph default
 and 
\emph on
limit
\emph default
 statements of a Degc program describe an integer program of a particular
 form.
\end_layout

\begin_layout Note
Any requirement is of the form 
\end_layout

\begin_layout Note
Suppose, for example, we have the following simple program:
\end_layout

\begin_layout LyX-Code
take 6 from { TakenCourse | faculty=Faculty.SC and subject=Subject.CMPUT }
     # R1
\end_layout

\begin_layout LyX-Code
take 6 from { TakenCourse | faculty=Faculty.SC }                        
       # R2
\end_layout

\begin_layout LyX-Code
limit 3 from { TakenCourse | level<200 }                               
        # L1
\end_layout

\begin_layout Standard
After some work, the compiler will reduce this program to some relevant
 pair-disjoint subsets:
\end_layout

\begin_layout LyX-Code
{ TakenCourse | subject=Subject.CMPUT and faculty=Faculty.SC and level<200
 }   # A1
\end_layout

\begin_layout LyX-Code
{ TakenCourse | subject=Subject.CMPUT and faculty=Faculty.SC and level>=200
 }  # A2
\end_layout

\begin_layout LyX-Code
{ TakenCourse | subject!=Subject.CMPUT and faculty=Faculty.SC and level<200
 }  # A3
\end_layout

\begin_layout LyX-Code
{ TakenCourse | subject!=Subject.CMPUT and faculty=Faculty.SC and level>=200
 } # A4
\end_layout

\begin_layout LyX-Code
{ TakenCourse | faculty!=Faculty.SC and level<200 }                     
       # A5
\end_layout

\begin_layout Standard
Suppose the input ontology has quantities of 
\begin_inset Formula $c_{1},\dots,c_{5}$
\end_inset

 for sets 
\begin_inset Formula $A_{1},\dots,A_{5}$
\end_inset

, respectively.
 Then, the following integer program is equivalent:
\end_layout

\begin_layout Quotation
maximize 
\begin_inset Formula $\sum_{i}\alpha_{i}$
\end_inset

 subject to:
\end_layout

\begin_deeper
\begin_layout Quotation
\begin_inset Formula $\alpha_{1}+\alpha_{2}\le c_{1}$
\end_inset

 # credits assigned from 
\begin_inset Formula $A_{1}$
\end_inset

 and 
\begin_inset Formula $A_{2}$
\end_inset

 to requirement 
\begin_inset Formula $R_{1}$
\end_inset

.
\end_layout

\begin_layout Quotation
\begin_inset Formula $\alpha_{3}+\alpha_{4}+\alpha_{5}+\alpha_{6}\le c_{2}$
\end_inset

 # credits assigned from 
\begin_inset Formula $A_{1}$
\end_inset

, 
\begin_inset Formula $A_{2}$
\end_inset

, 
\begin_inset Formula $A_{3}$
\end_inset

, and 
\begin_inset Formula $A_{4}$
\end_inset

 to requirement 
\begin_inset Formula $R_{2}$
\end_inset

.
\end_layout

\begin_layout Quotation
\begin_inset Formula $\alpha_{5}+\alpha_{6}$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\end_layout

\begin_layout Theorem
Any integer program of the form:
\end_layout

\begin_layout Theorem
maximize 
\begin_inset Formula $\alpha_{1}+\alpha_{2}+\cdots+\alpha_{n}+\beta_{1}+\beta_{2}+\cdots+\beta_{n}$
\end_inset


\end_layout

\begin_layout Theorem
subject to 
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Section
Compiling Degc
\end_layout

\begin_layout Subsection
Requirements
\end_layout

\begin_layout Standard
Degc has been built and tested using Ubuntu 12.10.
 This is currently the only supported platform.
\end_layout

\begin_layout Standard
Degc requires the following additional libraries and tools:
\end_layout

\begin_layout Itemize
GCC 4.7 or Clang 3.3
\end_layout

\begin_layout Itemize
Make 3.8
\end_layout

\begin_layout Itemize
Bison 2.5
\end_layout

\begin_layout Itemize
Flex 2.5
\end_layout

\begin_layout Itemize
Boost 1.49
\end_layout

\begin_layout Itemize
NullUnit 0.3 (available here: http://code.google.com/p/nullunit)
\end_layout

\begin_layout Subsection
Compiling
\end_layout

\begin_layout Standard
Navigate to the directory where Degc has been extracted and run the following
 command:
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout Standard
This command will automatically compile Degc and run the test cases.
\end_layout

\begin_layout Section
Development Guide
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
This portion of the document contains a high-level description of the major
 namespaces and components in the Degc implementation.
\end_layout

\begin_layout Standard
The Degc compiler is a multi-pass design, translating the input text to
 executable code over 8 self-contained stages.
 This design simplifies the implementation of new features, as the behavior
 of each stage can be implemented and tested separately.
\end_layout

\begin_layout Standard
The recommended approach for introducing new features is to write failing
 test cases.
 The compiler will automatically generate unimplemented feature errors,
 letting you know what files must be modified to support your feature.
\end_layout

\begin_layout Subsection
compiler::ast
\end_layout

\begin_layout Standard
The 
\emph on
ast
\emph default
 namespace contains the Abstract Syntax Tree implementation.
 The parser output consists of AST nodes, which encode the language in a
 tree structure.
\end_layout

\begin_layout Itemize

\noun on
factory
\noun default
 - An AST node factory, used by the parser rules to generate AST nodes.
\end_layout

\begin_layout Itemize

\noun on
node
\noun default
 - Contains declarations of AST node types.
\end_layout

\begin_layout Itemize

\noun on
visitor
\noun default
 - An abstract visitor interface used by later compiler stages to inspect
 the AST.
\end_layout

\begin_layout Subsection
compiler::diagnostics
\end_layout

\begin_layout Standard
The 
\emph on
diagnostics
\emph default
 namespace contains utilities and helper functions for error reporting.
\end_layout

\begin_layout Itemize

\noun on
error
\noun default
 - Container object describing a single error.
\end_layout

\begin_layout Itemize

\noun on
errorcode
\noun default
 - Names error codes.
\end_layout

\begin_layout Itemize

\noun on
errorlevel
\noun default
 - Names error levels.
\end_layout

\begin_layout Itemize

\noun on
errorlocation
\noun default
 - Container object describing the filename and position of an error.
\end_layout

\begin_layout Itemize

\noun on
report
\noun default
 - Abstract error report interface.
\end_layout

\begin_layout Itemize

\noun on
storedreport
\noun default
 - Error reporter which stores Error objects.
\end_layout

\begin_layout Itemize

\noun on
streamreport
\noun default
 - Error reporter which prints errors to a provided std::ostream&.
\end_layout

\begin_layout Subsection
compiler::grammar
\end_layout

\begin_layout Standard
The 
\emph on
grammar 
\emph default
namespace contains the parser and lexical analyzer.
\end_layout

\begin_layout Itemize

\noun on
instance
\noun default
 - Encapsulates an instance of the parser.
\end_layout

\begin_layout Itemize

\noun on
lexer.lex
\noun default
 - GNU Flex lexer rules.
\end_layout

\begin_layout Itemize

\noun on
parser.y
\noun default
 - GNU Bison parser rules.
\end_layout

\begin_layout Subsection
compiler::ir
\end_layout

\begin_layout Standard
The 
\emph on
ir
\emph default
 namespace contains helper classes for generating bytecode.
\end_layout

\begin_layout Itemize

\noun on
printer 
\noun default
- Abstract interface for a bytecode printer.
\end_layout

\begin_layout Itemize

\noun on
codeprinter
\noun default
 - Prints executable bytecode.
\end_layout

\begin_layout Itemize

\noun on
textprinter
\noun default
 - Prints human-readable text.
\end_layout

\begin_layout Itemize

\noun on
splitprinter
\noun default
 - Prints to multiple printer implementations.
\end_layout

\begin_layout Subsection
compiler::sg
\end_layout

\begin_layout Standard
The 
\emph on
sg
\emph default
 namespace contains the Semantic Graph implementation.
 The first compiler stages convert the Abstract Syntax Tree to the Semantic
 Graph data structure, which is more useful for performing semantic analysis.
\end_layout

\begin_layout Itemize

\noun on
error_helper
\noun default
 - Contains helper functions for reporting semantic errors.
\end_layout

\begin_layout Itemize

\noun on
module
\noun default
 - Records all of the symbols contained within a single module.
\end_layout

\begin_layout Itemize

\noun on
node
\noun default
 - Contains declarations of Semantic Graph node types.
\end_layout

\begin_layout Itemize

\noun on
scope_stack
\noun default
 - Contains a stack of scopes, allowing argument look-up within nested scopes.
\end_layout

\begin_layout Itemize

\noun on
scope
\noun default
 - A single scope containing symbols (e.g.
 function arguments, record members).
\end_layout

\begin_layout Itemize

\noun on
table
\noun default
 - Semantic Graph root node.
\end_layout

\begin_layout Itemize

\noun on
visitor
\noun default
 - An abstract visitor interface used by later compiler stages to inspect
 the SG.
\end_layout

\begin_layout Subsection
compiler::stages
\end_layout

\begin_layout Standard
The 
\emph on
stages
\emph default
 namespace contains the transformation rules used for translating the input
 program into the bytecode and network output.
\end_layout

\begin_layout Subsubsection
generate_ast
\end_layout

\begin_layout Standard
Constructs an Abstract Syntax Tree from an input source file.
\end_layout

\begin_layout Subsubsection
generate_sg
\end_layout

\begin_layout Standard
Constructs a basic Semantic Graph from the Abstract Syntax Tree generated
 in the previous stage.
\end_layout

\begin_layout Standard
The basic SG contains built-in types, along with user-defined modules and
 symbols, although the contents of type, function, and program symbols are
 not yet initialized.
\end_layout

\begin_layout Subsubsection
resolve_imports
\end_layout

\begin_layout Standard
Associates named imports with the actual symbol nodes generated in the previous
 stage.
\end_layout

\begin_layout Subsubsection
generate_members
\end_layout

\begin_layout Standard
Populates user-defined type symbols - records, enumerations, and function
 arguments.
\end_layout

\begin_layout Subsubsection
generate_expr
\end_layout

\begin_layout Standard
Generates expressions from the AST, replacing names with SG node references,
 and performs semantic analysis.
\end_layout

\begin_layout Subsubsection
constant_folding
\end_layout

\begin_layout Standard
Performs any possible off-line computation, converting constant expressions
 into constant values.
\end_layout

\begin_layout Subsubsection
generate_set_expr
\end_layout

\begin_layout Standard
Normalizes set filter expressions, verifying that set filters can be expressed
 as a union of orthogonal ranges.
\end_layout

\begin_layout Subsubsection
generate_code
\end_layout

\begin_layout Standard
Generates networks and bytecode for programs and functions.
\end_layout

\begin_layout Subsection
runtime::code
\end_layout

\begin_layout Standard
The 
\emph on
code
\emph default
 namespace contains data structures used to record facts about an executable
 program.
\end_layout

\begin_layout Itemize

\noun on
codebuffer
\noun default
 - Contains an executable bytecode stream.
\end_layout

\begin_layout Itemize

\noun on
codebufferreadstream
\noun default
 - Reads from a CodeBuffer at a specified offset.
\end_layout

\begin_layout Itemize

\noun on
codebufferwritestream
\noun default
 - Appends to a CodeBuffer, used by 
\noun on
compiler::ir::codeprinter
\noun default
.
\end_layout

\begin_layout Itemize

\noun on
functiontable
\noun default
 - Uniquely associates function names with a CodeBuffer offset.
\end_layout

\begin_layout Itemize

\noun on
programtable
\noun default
 - Uniquely associates program names with a program data structure.
\end_layout

\begin_layout Itemize

\noun on
recordtypetable
\noun default
 - Uniquely associates record names with an integer identifier.
\end_layout

\begin_layout Subsection
runtime::math
\end_layout

\begin_layout Standard
The 
\emph on
math
\emph default
 namespace contains utility classes used for compiling and solving programs.
\end_layout

\begin_layout Itemize

\noun on
fixed
\noun default
 - Defines a fixed-point decimal data type.
\end_layout

\begin_layout Itemize

\noun on
interval
\noun default
 - Defines an interval on a data type.
 Used by 
\noun on
set
\noun default
.
\end_layout

\begin_layout Itemize

\noun on
relation
\noun default
 - Defines the relations used by 
\noun on
set
\noun default
 to construct intervals.
\end_layout

\begin_layout Itemize

\noun on
set
\noun default
 - Defines a set on the ontology as a union of orthogonal ranges.
\end_layout

\begin_layout Subsection
runtime::solver
\end_layout

\begin_layout Standard
The 
\emph on
solver
\emph default
 namespace contains utility classes used for solving programs.
\end_layout

\begin_layout Itemize

\noun on
record
\noun default
 - Describes the contents of a single record field.
\end_layout

\begin_layout Itemize

\noun on
recordtable
\noun default
 - Abstract interface for a collection of records of a particular type.
\end_layout

\begin_layout Itemize

\noun on
linearrecordtable
\noun default
 - Implementation of RecordTable which uses linear search.
\end_layout

\begin_layout Itemize

\noun on
recordindex
\noun default
 - Collection of RecordTable instances, one for each type in the ontology.
\end_layout

\begin_layout Itemize

\noun on
network
\noun default
 - Network data structure and implementation of Edmonds-Karp algorithm.
\end_layout

\begin_layout Itemize

\noun on
program
\noun default
 - Program data structure.
\end_layout

\begin_layout Subsection
runtime::vm
\end_layout

\begin_layout Standard
The 
\emph on
vm
\emph default
 namespace contains the bytecode virtual machine implementation.
\end_layout

\begin_layout Itemize

\noun on
opcode
\noun default
 - Defines the opcodes which can be executed by the virtual machine.
\end_layout

\begin_layout Itemize

\noun on
virtualmachine
\noun default
 - The virtual machine implementation.
 Executes programs via bytecode interpretation.
\end_layout

\end_body
\end_document
