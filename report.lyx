#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
\usepackage{tkz-graph}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
theorems-ams-extended
enumitem
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Degc Language
\end_layout

\begin_layout Author
Jonathan Clark
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Language Specification
\end_layout

\begin_layout Section
Lexical Grammar
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
Lexical grammar is similar to the 
\emph on
Python
\emph default
 language.
\end_layout

\begin_layout Standard
The Degc tokenizer always returns the longest possible token which can be
 produced from the input.
 Tokens are delimited by non-matching characters and by whitespace.
 An unrecognized character or sequence is treated as an error.
\end_layout

\begin_layout Standard
In Degc, whitespace is syntactically significant.
 Four (
\begin_inset Formula $4$
\end_inset

) spaces are used to indent blocks, and other whitespace characters are
 ignored.
 Spaces are also ignored inside parenthesized 
\begin_inset Formula $(,)$
\end_inset

 and bracketed 
\begin_inset Formula $[,]$
\end_inset

 code.
\end_layout

\begin_layout Standard
Line comments are indicated with a hash # symbol.
 All input from the hash sign to the end of the current line is ignored.
\end_layout

\begin_layout Subsection
Identifiers
\end_layout

\begin_layout Standard
Types and functions are designated by a string identifier.
 Valid identifiers may begin with an underscore, or any upper- or lower-case
 English letter.
 Identifiers may not begin with numbers, but numbers are permitted in the
 remainder of the identifier.
\end_layout

\begin_layout Standard
Identifiers which begin with a number, or contain any symbols other than
 English letters, numbers, and underscores, are invalid.
\end_layout

\begin_layout Subsection
Literals
\end_layout

\begin_layout Standard
Degc includes the Boolean literal values 
\emph on
true
\emph default
 and 
\emph on
false
\emph default
.
\end_layout

\begin_layout Standard
Numeric literals denote fractional decimal numbers, and may contain any
 Arabic number from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $9$
\end_inset

, and optionally a single decimal 
\begin_inset Formula $.$
\end_inset

 which must be followed by additional numbers.
 Degc supports fixed-precision numbers with 
\begin_inset Formula $\varepsilon=0.0001$
\end_inset

.
\end_layout

\begin_layout Subsection
Keywords and Punctuators
\end_layout

\begin_layout Standard
The Degc lexicon contains the following keywords: 
\emph on
all, and, any, assert, as, best, by, either, else, embed, enum, exists,
 extends, for, from, function, if, import, intersect, in, limit, module,
 not, or, panic, program, record, setminus, set, take, union, with.
\end_layout

\begin_layout Standard
The Degc lexicon also contains the following punctuators: 
\emph on
@ : , .
 -> + - * / < <= > >= = != ( ) [ ] { } |
\end_layout

\begin_layout Section
Syntax and Semantics
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
Degc is a declarative language for describing academic programs.
 As such, Degc programs are written to model the given problem, rather than
 written to execute specific computations.
\end_layout

\begin_layout Standard
Degc programs operate over an input 
\emph on
ontology
\emph default
 - a set of facts, which are described using records.
 Degc programs do not have direct access to the contents of records.
 Instead, Degc programs contain assertions about the ontology.
 A Degc program evaluates 
\emph on
true
\emph default
 when all of its assertions are true, and 
\emph on
false
\emph default
 otherwise.
\end_layout

\begin_layout Subsection
Modules
\end_layout

\begin_layout Standard
Degc definitions are stored inside modules.
 Each module is a self-contained namespace.
 In order to access a symbol from a different namespace, it must be manually
 imported into the current module.
\end_layout

\begin_layout Subsubsection
Module declaration
\end_layout

\begin_layout Standard
The first line of a Degc translation unit must be a module declaration.
\end_layout

\begin_layout LyX-Code
module ca.ualberta.science
\end_layout

\begin_layout Standard
Module declarations are non-unique.
 By standard convention, module names should reflect the organizational
 structure of the authoring institution (generally, a fully-qualified domain
 name in reverse order).
\end_layout

\begin_layout Standard
A typical convention will be {country code}.{parent institution}.{faculty}.{departm
ent}.
\end_layout

\begin_layout Subsubsection
Importing symbols
\end_layout

\begin_layout Standard
Symbols from the current module (including those defined in other translation
 units) are automatically imported.
 Symbols from other modules may be imported using an 
\emph on
import
\emph default
 directive.
\end_layout

\begin_layout LyX-Code
from ca.ualberta import TakenCourse
\end_layout

\begin_layout LyX-Code
from ca.ualberta.science import (Honors, General as BScGeneral,)
\end_layout

\begin_layout Standard
Import directives are optional.
 If used, they must immediately follow the module declaration (not including
 comments and whitespace).
\end_layout

\begin_layout Subsection
Types
\end_layout

\begin_layout Standard
Degc is strongly and statically typed, with three distinct forms of typename.
\end_layout

\begin_layout Standard
In the following, a type is 
\emph on
assignment-compatible
\emph default
 with a target type if that type can be transparently treated as an instance
 of the target type (for the purposes of, for example, passing as a function
 argument).
\end_layout

\begin_layout Subsubsection
Boolean types
\end_layout

\begin_layout Standard
All values of Boolean type are either 
\emph on
true
\emph default
 or 
\emph on
false
\emph default
.
 Boolean types are assignment-compatible only with the boolean type.
\end_layout

\begin_layout Standard
The Boolean typename is:
\end_layout

\begin_layout LyX-Code
bool
\end_layout

\begin_layout Subsubsection
Numeric types
\end_layout

\begin_layout Standard
The Degc numeric type is a fixed-precision number with four decimal places
 (
\begin_inset Formula $\varepsilon=0.0001$
\end_inset

).
 The number type is assignment-compatible only with the number type.
\end_layout

\begin_layout Standard
The number type has two typenames:
\end_layout

\begin_layout LyX-Code
number
\end_layout

\begin_layout LyX-Code
quantity
\end_layout

\begin_layout Standard
For the purposes of the type system, 
\emph on
number
\emph default
 and 
\emph on
quantity
\emph default
 are indistinct.
 The 
\emph on
quantity
\emph default
 type differs semantically only when used as a record field.
\end_layout

\begin_layout Subsubsection
Enumeration and Record types
\end_layout

\begin_layout Standard
The enumeration and record types reference user-defined enumerations and
 records.
 The typenames of these types are simply the identifiers used to name or
 import these types.
\end_layout

\begin_layout Standard
Enumeration and record types are assignment-compatible only with their own
 type.
\end_layout

\begin_layout Subsubsection
Program types
\end_layout

\begin_layout Standard
Program types reference user-defined programs.
 The typenames of these types are the identifiers used to name or import
 these types.
\end_layout

\begin_layout Standard
Program types are assignment-compatible with any base program type.
 For example, if the program 
\emph on
ChildProgram
\emph default
 inherits from 
\emph on
BaseProgram
\emph default
, then any value of type 
\emph on
ChildProgram
\emph default
 is assignment-compatible with the 
\emph on
BaseProgram
\emph default
 type.
 However, a value of type 
\emph on
BaseProgram
\emph default
 is 
\emph on
not
\emph default
 assignment-compatible with the 
\emph on
ChildProgram
\emph default
 type.
\end_layout

\begin_layout Subsubsection
Set types
\end_layout

\begin_layout Standard
Set types reference subsets of the ontology.
 All set types are specialized with a record type, denoting the element
 type of the subset.
\end_layout

\begin_layout Standard
Set typenames feature a record typename, in the following format:
\end_layout

\begin_layout LyX-Code
set(TakenCourse)
\end_layout

\begin_layout Standard
A value of a set type is assignment-compatible only with the identical set
 type.
\end_layout

\begin_layout Subsubsection
Function types
\end_layout

\begin_layout Standard
Function types are normally only invoked for implementing higher-order functions.
 All function types 
\end_layout

\begin_layout Standard
Function typenames include argument and return typenames:
\end_layout

\begin_layout LyX-Code
function({arg1}, {arg2}, ..., {argN})->{return typename}
\end_layout

\begin_layout LyX-Code
function()->bool
\end_layout

\begin_layout LyX-Code
function(number, number)->set(TakenCourse)
\end_layout

\begin_layout LyX-Code
function(function(number, number)->bool, set(TakenCourse))->bool
\end_layout

\begin_layout Standard
A function is assignment-compatible only with another function type, and
 only if the return values and arguments are also assignment-compatible.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Declarations
\end_layout

\begin_layout Subsubsection
Records
\end_layout

\begin_layout Standard
A record is a quantum of the input ontology.
 Records contain relevant facts, such as courses or certifications taken,
 student status, etc.
\end_layout

\begin_layout Standard
A record may optionally have one 
\emph on
quantity
\emph default
 field.
 A record type must have a quantity field to use 
\emph on
take 
\emph default
and 
\emph on
limit 
\emph default
statements.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
record TakenCourse:
\end_layout

\begin_layout LyX-Code
    Faculty faculty
\end_layout

\begin_layout LyX-Code
    Subject subject
\end_layout

\begin_layout LyX-Code
    number level
\end_layout

\begin_layout LyX-Code
    quantity credits
\end_layout

\begin_layout Subsubsection
Enumerations
\end_layout

\begin_layout Standard
Enumerations are a list of options.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
enum Subject:
\end_layout

\begin_layout LyX-Code
    CMPUT
\end_layout

\begin_layout LyX-Code
    MATH
\end_layout

\begin_layout LyX-Code
    ENGL
\end_layout

\begin_layout LyX-Code
    PHIL
\end_layout

\begin_layout Subsubsection
Functions
\end_layout

\begin_layout Standard
Degc contains an embedded functional programming language which can be accessed
 by writing functions.
 Degc supports higher-order functions, but not lexical closures.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
function SubjectLevelCourse(Subject sub, number lev) -> set(TakenCourse):
\end_layout

\begin_layout LyX-Code
    { TakenCourse | subject = sub and level >= lev and level < (lev + 100)
 }
\end_layout

\begin_layout Subsubsection
Programs
\end_layout

\begin_layout Standard
Degc programs describe statements about the ontology.
 Programs may inherit from other programs.
 Programs may be parameterized, but are restricted to enumeration arguments.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
program ExampleProgram:
\end_layout

\begin_layout LyX-Code
    take 6 in { TakenCourse | subject = Subject.CMPUT }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
program ExampleChildProgram extends BaseProgram:
\end_layout

\begin_layout LyX-Code
    take 6 in { TakenCourse | subject = Subject.CMPUT }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
program ExampleParameterizedProgram(Subject majorSubject):
\end_layout

\begin_layout LyX-Code
    take 6 in { TakenCourse | subject = majorSubject }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
program ExampleChildProgram(Subject sub) extends BaseProgram(sub):
\end_layout

\begin_layout LyX-Code
    take 6 in { TakenCourse | subject = majorSubject }
\end_layout

\begin_layout Subsection
Expressions
\end_layout

\begin_layout Subsubsection
Overview
\end_layout

\begin_layout Standard
Deg expressions are similar to those in other languages.
 As is typical, function calls have the highest precedence, followed by
 member access, unary operators (arithmetic and boolean negation), multiplicatio
n, addition, relations, equality, logical and, and logical or.
 A higher precedence may be imposed with parentheses.
\end_layout

\begin_layout Subsubsection
Logical and Arithmetic
\end_layout

\begin_layout Standard
Degc supports the usual arithmetic operators for number types: 
\emph on
+,-,*,/
\emph default
.
\end_layout

\begin_layout Standard
Degc also supports the following logical operations: 
\emph on
and, or, not
\emph default
.
\end_layout

\begin_layout Subsubsection
Relational
\end_layout

\begin_layout Standard
Degc supports the following relational operators: 
\emph on
=,!=,>,>=,<,<=
\emph default
.
\end_layout

\begin_layout Standard
Nominal types - enumerations and booleans - support the identity relations.
\end_layout

\begin_layout Standard
The ordinal numeric type supports all relational operators.
\end_layout

\begin_layout Subsubsection
Set
\end_layout

\begin_layout Standard
Set expressions are used to describe a portion of the ontology.
 They are constructed using a typical set builder notation.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
{ TakenCourse }
\end_layout

\begin_layout Standard
This code describes a set of all records with the type 
\emph on
TakenCourse
\emph default
.
\end_layout

\begin_layout LyX-Code
{ TakenCourse | subject = Subject.CMPUT and level < 200 }
\end_layout

\begin_layout Standard
This code describes a set of all records with the type 
\family typewriter
\emph on
TakenCourse
\emph default
, a subject of 
\emph on
CMPUT
\emph default
, and a level which is below 
\begin_inset Formula $200$
\end_inset

.
\end_layout

\begin_layout Standard
It must be possible to represent the constructed set as a union of orthogonal
 ranges.
 As a result, set clause relations must each depend on a single record member,
 and that member must be isolated on a single side of the relational operator.
\end_layout

\begin_layout Standard
Sets support the 
\emph on
exists, union, intersect, 
\emph default
and 
\emph on
setminus
\emph default
 operators.
 The 
\emph on
exists
\emph default
 operator returns true if and only if there is at least one record matching
 the input set.
 The other operators function as expected.
\end_layout

\begin_layout Subsubsection
Selection
\end_layout

\begin_layout Standard
The selection, or 
\emph on
if/else
\emph default
 expression, is used for predicated branching inside expressions.
 
\emph on
If/else
\emph default
 can only be used inside functions.
\end_layout

\begin_layout LyX-Code
if x = 5:
\end_layout

\begin_layout LyX-Code
    true
\end_layout

\begin_layout LyX-Code
else if x > 10:
\end_layout

\begin_layout LyX-Code
    true
\end_layout

\begin_layout LyX-Code
else:
\end_layout

\begin_layout LyX-Code
    false
\end_layout

\begin_layout Standard
The type of the selection expression is the nearest assignment-compatible
 type common to all branches of the expression.
\end_layout

\begin_layout Subsubsection
Panic
\end_layout

\begin_layout Standard
Degc supports a rudimentary exception mechanism.
 A panic expression will immediately cause the executing program to terminate
 with a result of 
\emph on
false
\emph default
.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
function AbortIfTrue(bool predicate)->bool:
\end_layout

\begin_layout LyX-Code
    if predicate:
\end_layout

\begin_layout LyX-Code
        panic
\end_layout

\begin_layout LyX-Code
    else:
\end_layout

\begin_layout LyX-Code
        true
\end_layout

\begin_layout Subsection
Statements
\end_layout

\begin_layout Subsubsection
Overview
\end_layout

\begin_layout Standard
Program statements are used to describe facts about the ontology.
 In the following, an asterisk (*) indicates that the statement type is
 planned but not currently supported by the reference implementation.
\end_layout

\begin_layout Subsubsection
Assertions
\end_layout

\begin_layout Standard
Assertions execute a boolean expression.
 If the expression evaluates as 
\emph on
false
\emph default
, the current execution is rejected.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
assert exists { RoyalConservatoryPiano | grade >= 6 }
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsubsection
Embed
\end_layout

\begin_layout Standard
Embed statements include, in-line, the contents of another program.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
embed ComputingScienceMajor
\end_layout

\begin_layout Standard
Parameterized programs may also be embedded with included arguments.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
embed MajorProgramMap(majorSubject) with (minorSubject,)
\end_layout

\begin_layout Standard
The embed keyword may also be used to enclose program statements in a nested
 block:
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
take 6 in { TakenCourse | subject = majorSubject }
\end_layout

\begin_layout LyX-Code
embed:
\end_layout

\begin_layout LyX-Code
    assert exists { StudentRegistered }
\end_layout

\begin_layout LyX-Code
    take 6 in { TakenCourse | subject = minorSubject }
\end_layout

\begin_layout LyX-Code
take 3 in { TakenCourse }
\end_layout

\begin_layout Subsubsection
Disjunction
\end_layout

\begin_layout Standard
Disjunctions are used to indicate a non-discriminated branch.
 Program execution is successful if at least one branch may be taken.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
either:
\end_layout

\begin_layout LyX-Code
    assert exists { TakenCourse | subject = Subject.MUS and level = 110 }
\end_layout

\begin_layout LyX-Code
or:
\end_layout

\begin_layout LyX-Code
    assert exists { PianoExemptionExam | grade >= 0.8 }
\end_layout

\begin_layout LyX-Code
or:
\end_layout

\begin_layout LyX-Code
    assert exists { RoyalConservatoryPiano | grade >= 6 }
\end_layout

\begin_layout Subsubsection
For All*
\end_layout

\begin_layout Standard
For All loops execute the statement body for each record in the matching
 set.
 This allows programs to make assertions about all records in the ontology.
\end_layout

\begin_layout Standard
For All loops may not contain 
\emph on
take
\emph default
 or 
\emph on
limit
\emph default
 statements.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
for all course in { TakenCourse | subject = Subject.CMPUT }:
\end_layout

\begin_layout LyX-Code
    assert course.grade >= 2.7
\end_layout

\begin_layout Subsubsection
For Any*
\end_layout

\begin_layout Standard
For Any loops execute the statement body for any one, arbitrarily-chosen
 record in the ontology.
\end_layout

\begin_layout Standard
For Any loops may not contain 
\emph on
take
\emph default
 or 
\emph on
limit
\emph default
 statements.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
for any status in { RegistrationStatus }:
\end_layout

\begin_layout LyX-Code
    assert status.registered
\end_layout

\begin_layout Subsubsection
For Best*
\end_layout

\begin_layout Standard
For Best loops execute the statement body for the best matching record,
 where the best record is identified with an order predicate.
\end_layout

\begin_layout Standard
For Best loops may not contain 
\emph on
take
\emph default
 or 
\emph on
limit
\emph default
 statements.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
function HighestGrade(TakenCourse a, TakenCourse b)->bool:
\end_layout

\begin_layout LyX-Code
    a.grade >= b.grade
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
for best course by HighestGrade in { TakenCourse }:
\end_layout

\begin_layout LyX-Code
    assert course.grade >= 4.0
\end_layout

\begin_layout Subsubsection
Conditional
\end_layout

\begin_layout Standard
Conditional statements are used to indicate a discriminated branch.
 Conditional statements are used to branch program execution predicated
 upon the value of a boolean expression.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
if exists { RoyalConservatoryPiano | grade >= 6 }:
\end_layout

\begin_layout LyX-Code
    assert not exists { PianoExemptionExam }
\end_layout

\begin_layout LyX-Code
else:
\end_layout

\begin_layout LyX-Code
    assert exists { PianoExemptionExam }
\end_layout

\begin_layout Subsubsection
Take
\end_layout

\begin_layout Standard
Take statements are used to allocate a specified quantity from a set.
 Once taken, the quantity cannot be used to fulfill another 
\emph on
take
\emph default
 requirement.
\end_layout

\begin_layout Standard
For example, an academic program may require 
\begin_inset Formula $6$
\end_inset

 credits from art courses and 
\begin_inset Formula $3$
\end_inset

 additional credits in free options.
 Although art credits may be applied toward the free option requirement,
 art credits may not simultaneously be applied to both requirements.
\end_layout

\begin_layout LyX-Code
take 6 in { TakenCourse | faculty = Faculty.AR }
\end_layout

\begin_layout LyX-Code
take 3 in { TakenCourse }
\end_layout

\begin_layout Standard
In this example, the student always requires at least 
\begin_inset Formula $9$
\end_inset

 credits in taken courses.
\end_layout

\begin_layout Subsubsection
Limit
\end_layout

\begin_layout Standard
Limit statements are used to constrain the quantity which may be taken from
 a set.
\end_layout

\begin_layout Standard
For example, a typical academic program will apply a restriction on the
 number of introductory-level courses which may be applied to a program
 of study.
 Limit statements allow these types of requirements to be imposed while
 still maximizing the assignment of credits.
\end_layout

\begin_layout LyX-Code
limit 42 in { TakenCourse | level < 200 }
\end_layout

\begin_layout Standard
Due to the algorithm used for solving programs, limit sets must either be
 point-wise disjoint or a sub/super-set.
 Compliant Degc compilers must produce an error when a program contains
 limit statements which do not satisfy this restriction.
\end_layout

\begin_layout Chapter
Execution Model
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
Degc uses a hybrid execution model which combines an integer program with
 assertions defined using a programming language.
\end_layout

\begin_layout Standard
Due to the specific form of integer programs written in Degc, it is possible
 to describe the integer program portions as an instance of network max-flow.
 This correspondence allows a larger amount of preprocessing and a guaranteed
 polynomial execution time.
 The disadvantage to this approach is a greater demand for storage space:
 since branches may produce significantly different networks, each possible
 branch and combination of program parameters must be enumerated into a
 separate network.
 See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:Alternative-Approaches"

\end_inset

 for a detailed discussion of alternative approaches.
\end_layout

\begin_layout Standard
The accompanying bytecode program serves to prune the set of feasible networks
 which must be tested.
 Any branch which contains a failing assertion is flagged as infeasible,
 and it is excluded during program execution.
\end_layout

\begin_layout Standard
Programs are thus executed in three major stages:
\end_layout

\begin_layout Enumerate
The fully specified program is selected based on the input parameters.
\end_layout

\begin_layout Enumerate
The bytecode program is executed, masking impossible branches.
\end_layout

\begin_layout Enumerate
The max-flow is computed for each possible branch.
\end_layout

\begin_deeper
\begin_layout Enumerate
Credit quantities are computed from the ontology and assigned to the network
 inputs.
\end_layout

\begin_layout Enumerate
The max-flow is computed with the Edmonds-Karp algorithm.
\end_layout

\begin_layout Enumerate
If the max-flow is sufficient, the program has been satisfied and returns
 immediately.
\end_layout

\end_deeper
\begin_layout Section
Integer Program - Network Correspondence
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
The 
\emph on
take
\emph default
 and 
\emph on
limit
\emph default
 statements of a Degc program describe an integer program of a particular
 form.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $S_{1},\dots,S_{n}$
\end_inset

 be disjoint subsets of the ontology of a single common type.
 A Degc integer program consists of some number of variables, 
\begin_inset Formula $\alpha_{1},\dots,\alpha_{\ell}\in\mathbb{Z}$
\end_inset

, which we may intuitively understand as an assignment of credits from the
 
\begin_inset Formula $S_{1},\dots S_{n}$
\end_inset

 input subsets to the requirements that must be satisfied.
 Since the goal is to fully satisfy all requirements, 
\begin_inset Formula $\alpha_{1}+\alpha_{2}+\cdots+\alpha_{\ell}$
\end_inset

 should be maximized, subject to three types of constraints: 
\emph on
supply
\emph default
 constraints, 
\emph on
demand
\emph default
 constraints, and 
\emph on
limit
\emph default
 constraints.
\end_layout

\begin_layout Standard
Supply constraints are imposed implicitly by the input.
 Suppose 
\begin_inset Formula $\alpha_{b_{1}},\dots,\alpha_{b_{k}}$
\end_inset

 represent the amounts of quantity assigned from the ontology subset 
\begin_inset Formula $S_{b}$
\end_inset

 to various requirements.
 If the input ontology only has some 
\begin_inset Formula $c_{b}\in\mathbb{Z}$
\end_inset

 quantity in subset 
\begin_inset Formula $S_{b}$
\end_inset

, it follows that 
\begin_inset Formula $\alpha_{b_{1}}+\alpha_{b_{2}}+\cdots+\alpha_{b_{k}}\le c_{b}$
\end_inset

, since the total amount of quantity consumed from 
\begin_inset Formula $S_{b}$
\end_inset

 cannot exceed 
\begin_inset Formula $c_{b}$
\end_inset

.
\end_layout

\begin_layout Standard
Demand constraints are imposed by the program.
 Suppose a requirement 
\begin_inset Formula $R_{d}$
\end_inset

 for 
\begin_inset Formula $c_{d}\in\mathbb{Z}$
\end_inset

 quantity takes 
\begin_inset Formula $\alpha_{d_{1}},\dots,\alpha_{d_{j}}$
\end_inset

 quantity respectively from each of 
\begin_inset Formula $S_{e_{1}},S_{e_{2}},\dots,S_{e_{j}}$
\end_inset

.
 Then, 
\begin_inset Formula $\alpha_{d_{1}}+\alpha_{d_{2}}+\cdots+\alpha_{d_{j}}\ge c_{d}$
\end_inset

, since at least 
\begin_inset Formula $c_{d}$
\end_inset

 quantity must be consumed by such a requirement for it to be satisfied.
\end_layout

\begin_layout Standard
Limits are imposed by constraining the total amount of quantity which may
 be consumed from some subsets.
 Suppose 
\begin_inset Formula $L_{g}$
\end_inset

 is a limit of 
\begin_inset Formula $c_{g}\in\mathbb{Z}$
\end_inset

 imposed upon some collection of subsets which respectively contribute 
\begin_inset Formula $\alpha_{g_{1}},\alpha_{g_{2}},\dots,\alpha_{g_{p}}$
\end_inset

 quantity to some number of requirements.
 Then, 
\begin_inset Formula $\alpha_{g_{1}}+\alpha_{g_{2}}+\cdots+\alpha_{g_{p}}\le c_{g}$
\end_inset

.
\end_layout

\begin_layout Standard
With the exception of limit constraints, each of these constraints can be
 directly represented as a network flow.
 Limit constraints require some modification, which is discussed below.
\end_layout

\begin_layout Subsection
Supply Constraints
\end_layout

\begin_layout Standard
As discussed previously, suppose 
\begin_inset Formula $\alpha_{b_{1}},\alpha_{b_{2}},\dots,\alpha_{b_{k}}$
\end_inset

 represent the amounts of quantity consumed from an ontology subset 
\begin_inset Formula $S_{b}$
\end_inset

.
 Then, 
\begin_inset Formula $\alpha_{b_{1}}+\alpha_{b_{2}}+\cdots+\alpha_{b_{k}}\le c_{b}$
\end_inset

, where 
\begin_inset Formula $c_{b}\in\mathbb{Z}$
\end_inset

 is the total amount of quantity contained within 
\begin_inset Formula $S_{b}$
\end_inset

.
\end_layout

\begin_layout Standard
This constraint can be represented directly in a network: let 
\begin_inset Formula $S_{b}$
\end_inset

 be represented by a graph node, with outbound arcs to requirements representing
 
\begin_inset Formula $\alpha_{b_{1}},\dots,\alpha_{b_{k}}$
\end_inset

.
 Then, the total flow through 
\begin_inset Formula $S_{b}$
\end_inset

 is constrained by adding a 
\begin_inset Formula $c_{b}$
\end_inset

-capacity arc from the 
\begin_inset Formula $S_{b}$
\end_inset

 node to the network source node (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:ip-supply-constraint"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikzstyle{vertex}=[circle,draw,thick,fill=none,minimum size=20pt,inner sep=0pt]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{edge} = [draw,thick,->]
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

	[scale=1,auto=left,every node/.style={circle,fill=white!20}]
\end_layout

\begin_layout Plain Layout

    
\backslash
foreach 
\backslash
pos/
\backslash
name in {{(5,0)/s},{(5,6)/t},
\end_layout

\begin_layout Plain Layout

                            {(5,2)/S_b},{(2,4)/R_1},{(5,4)/R_2},{(8,4)/R_3}}
\end_layout

\begin_layout Plain Layout

		
\backslash
node[vertex] (
\backslash
name) at 
\backslash
pos {$
\backslash
name$};
\end_layout

\begin_layout Plain Layout

	
\backslash
foreach 
\backslash
source/
\backslash
dest/
\backslash
name in {s/S_b/c_b,S_b/R_1/
\backslash
alpha_{b_1},S_b/R_2/
\backslash
alpha_{b_2},S_b/R_3/
\backslash
alpha_{b_3},R_1/t/c_1,R_2/t/c_2,R_3/t/c_3}
\end_layout

\begin_layout Plain Layout

		
\backslash
path[edge] (
\backslash
source) -- (
\backslash
dest) node [pos=0.4,fill=white,rectangle,above] {$
\backslash
name$};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ip-supply-constraint"

\end_inset

Illustrates the network flow analogue to the implicit supply constraint.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Demand Constraints
\end_layout

\begin_layout Standard
As discussed previously, suppose 
\begin_inset Formula $\alpha_{d_{1}},\alpha_{d_{2}},\dots,\alpha_{d_{\ell}}$
\end_inset

 represent the amounts of quantity consumed by a requirement 
\begin_inset Formula $R_{d}$
\end_inset

.
 Then, 
\begin_inset Formula $\alpha_{d_{1}}+\alpha_{d_{2}}+\cdots+\alpha_{d_{\ell}}\ge c_{d}$
\end_inset

, where 
\begin_inset Formula $c_{d}\in\mathbb{Z}$
\end_inset

 is the total amount of quantity demanded by the requirement.
\end_layout

\begin_layout Standard
As before, this constraint can be represented directly in a network: let
 
\begin_inset Formula $R_{d}$
\end_inset

 be represented by a graph node, with inbound arcs from the disjoint subsets
 representing 
\begin_inset Formula $\alpha_{d_{1}},\dots,\alpha_{d_{\ell}}$
\end_inset

, and an additional infinite-capacity arc from the requirement node to the
 network sink node.
 Since the solver computes max-flow, the 
\begin_inset Formula $\alpha_{d_{1}},\dots,\alpha_{d_{i}}$
\end_inset

 are maximized, with the requirement successfully satisfied iff 
\begin_inset Formula $\alpha_{d_{1}}+\cdots+\alpha_{d_{i}}\ge c_{d}$
\end_inset

 (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:ip-demand-constraint"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikzstyle{vertex}=[circle,draw,thick,fill=none,minimum size=20pt,inner sep=0pt]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{edge} = [draw,thick,->]
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout

	[scale=1,auto=left,every node/.style={circle,fill=white!20}]
\end_layout

\begin_layout Plain Layout

    
\backslash
foreach 
\backslash
pos/
\backslash
name in {{(5,0)/s},{(5,6)/t},
\end_layout

\begin_layout Plain Layout

                            {(2,2)/S_1},{(5,2)/S_2},{(8,2)/S_3},
\end_layout

\begin_layout Plain Layout

                            {(5,4)/R_d}}
\end_layout

\begin_layout Plain Layout

		
\backslash
node[vertex] (
\backslash
name) at 
\backslash
pos {$
\backslash
name$};
\end_layout

\begin_layout Plain Layout

	
\backslash
foreach 
\backslash
source/
\backslash
dest/
\backslash
name in {s/S_1/c_1,s/S_2/c_2,s/S_3/c_3,S_1/R_d/
\backslash
alpha_{d_1},S_2/R_d/
\backslash
alpha_{d_2},S_3/R_d/
\backslash
alpha_{d_3},R_d/t/f_d}
\end_layout

\begin_layout Plain Layout

		
\backslash
path[edge] (
\backslash
source) -- (
\backslash
dest) node [pos=0.4,fill=white,rectangle,above] {$
\backslash
name$};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ip-demand-constraint"

\end_inset

Illustrates the network flow analogue to the implicit supply constraint.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Limit Constraints
\end_layout

\begin_layout Standard
In general, limit constraints cannot be represented in a network.
 The exception is when every limit is either a subset, a superset, or disjoint
 from every other set involved in a limit.
\end_layout

\begin_layout Subsubsection
Disjoint
\end_layout

\begin_layout Standard
Suppose 
\begin_inset Formula $L$
\end_inset

 is a disjoint limit constraint, imposing a constraint 
\begin_inset Formula $c$
\end_inset

 on a family of ontology subsets 
\begin_inset Formula $S_{1},S_{2},\dots,S_{n}$
\end_inset

, which are constrained to supply maximum quantities of 
\begin_inset Formula $s_{1},s_{2},\dots,s_{n}$
\end_inset

, respectively.
 Suppose also 
\begin_inset Formula $\alpha_{1},\alpha_{2},\dots,\alpha_{n}\in\mathbb{Z}$
\end_inset

, where 
\begin_inset Formula $\alpha_{i}$
\end_inset

 represents the amount of quantity 
\begin_inset Formula $S_{i}$
\end_inset

 provides to any number of requirements.
 Then, 
\begin_inset Formula $L$
\end_inset

 has an equivalent 
\emph on
demand constraint 
\emph default
representation.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $\beta_{i}=s_{i}-\alpha_{i}$
\end_inset

, for any 
\begin_inset Formula $1\le i\le n$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{eqnarray*}
 &  & \sum_{i=1}^{n}\alpha_{i}\le c\\
 & \iff & -\sum_{i=1}^{n}\alpha_{i}\ge-c\\
 & \iff & \sum_{i=1}^{n}s_{i}-\sum_{i=1}^{n}\alpha_{i}\ge\sum_{i=1}^{n}s_{i}-c\\
 & \iff & \sum_{i=1}^{n}\beta_{i}\ge\sum_{i=1}^{n}s_{i}-c
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Proof
Which is, indeed, the form needed for a demand constraint.
\end_layout

\begin_layout Standard
Therefore, disjoint limit constraints are constructed as demand constraints,
 where the sum of all incoming quantity is greater than the difference between
 the sum of all possible quantity and the limit constraint value.
\end_layout

\begin_layout Standard
(Note that all of the 
\begin_inset Formula $\beta_{i}$
\end_inset

 are positive.
 Therefore, when the supplied quantity is less than the limit amount, all
 of the 
\begin_inset Formula $\beta_{i}=0$
\end_inset

.)
\end_layout

\begin_layout Subsubsection
Superset/Subset
\end_layout

\begin_layout Standard
Subset limit constraints are constructed similar to disjoint limit constraints,
 with the zero-clamped requirement constraint of each subset subtracted
 from the requirement constraint of the next-largest superset.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $L_{1},L_{2}$
\end_inset

 be limit constraints, such that 
\begin_inset Formula $L_{1}$
\end_inset

 is the largest subset of 
\begin_inset Formula $L_{2}$
\end_inset

 among all limit constraints.
 Suppose the corresponding limit for 
\begin_inset Formula $L_{1}$
\end_inset

 is 
\begin_inset Formula $\sum_{i=1}^{n}\beta_{i}\ge\sum_{i=1}^{n}s_{i}-c$
\end_inset

, while the corresponding limit for 
\begin_inset Formula $L_{2}$
\end_inset

 is 
\begin_inset Formula $\sum_{i=1}^{m}\beta_{i}\ge\sum_{i=1}^{m}s_{i}-d$
\end_inset

 (where, clearly, 
\begin_inset Formula $m>n$
\end_inset

).
\end_layout

\begin_layout Proof
Case 1: Suppose 
\begin_inset Formula $\sum_{i=1}^{n}s_{i}-c$
\end_inset

 is non-positive.
 Then, 
\begin_inset Formula $\sum_{i=1}^{n}\beta_{i}=0$
\end_inset

, and the constraint is valid and applies only to 
\begin_inset Formula $L_{2}\setminus L_{1}$
\end_inset

.
\end_layout

\begin_layout Proof
Case 2: Suppose 
\begin_inset Formula $\sum_{i=1}^{n}s_{i}-c$
\end_inset

 is positive.
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{eqnarray*}
 &  & \sum_{i=1}^{m}\beta_{i}\ge\sum_{i=1}^{m}s_{i}-d\\
 & \iff & \sum_{i=1}^{m}\beta_{i}-\sum_{i=1}^{n}\beta_{i}\ge\sum_{i=1}^{m}s_{i}-d-\sum_{i=1}^{n}s_{i}+c\\
 & \iff & \sum_{i=n+1}^{m}\beta_{i}\ge\sum_{i=n+1}^{m}s_{i}-\left(d+c\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Proof
Therefore, subtracting the subset limit constraint from the superset limit
 constraint yields a new demand constraint, implicating only the ontology
 subsets of 
\begin_inset Formula $L_{2}\setminus L_{1}$
\end_inset

.
\end_layout

\begin_layout Subsection
Alternative Approaches
\begin_inset CommandInset label
LatexCommand label
name "sub:Alternative-Approaches"

\end_inset


\end_layout

\begin_layout Standard
There are several possible alternative approaches which may warrant consideratio
n in the future.
\end_layout

\begin_layout Subsubsection
Depth-first exploration with backtracking
\end_layout

\begin_layout Standard
It is possible to directly evaluate program requirements.
 This approach offers a reduced implementation complexity, more flexibility,
 and has already been successfully prototyped.
 Unfortunately, repeated backtracking implies a potentially-exponential
 number of expensive queries against the input ontology, which may not be
 reasonable in a production setting.
\end_layout

\begin_layout Subsubsection
Integer program solver
\end_layout

\begin_layout Standard
This model was chosen specifically to guarantee a polynomial execution time.
 In practice, however, a general integer program solver may be superior
 to the Edmonds-Karp solver, while simultaneously eliminating the unfortunate
 disjoint/subset restriction on the limit constraints.
\end_layout

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Section
Compiling Degc
\end_layout

\begin_layout Subsection
Requirements
\end_layout

\begin_layout Standard
Degc has been built and tested using Ubuntu 12.10.
 This is currently the only supported platform.
\end_layout

\begin_layout Standard
Degc requires the following additional libraries and tools:
\end_layout

\begin_layout Itemize
GCC 4.7 or Clang 3.3
\end_layout

\begin_layout Itemize
Make 3.8
\end_layout

\begin_layout Itemize
Bison 2.5
\end_layout

\begin_layout Itemize
Flex 2.5
\end_layout

\begin_layout Itemize
Boost 1.49
\end_layout

\begin_layout Itemize
NullUnit 0.3 (available here: http://code.google.com/p/nullunit)
\end_layout

\begin_layout Subsection
Compiling
\end_layout

\begin_layout Standard
Navigate to the directory where Degc has been extracted and run the following
 command:
\end_layout

\begin_layout LyX-Code
$ make
\end_layout

\begin_layout Standard
This command will automatically compile Degc and run the test cases.
\end_layout

\begin_layout Section
Development Guide
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
This portion of the document contains a high-level description of the major
 namespaces and components in the Degc implementation.
\end_layout

\begin_layout Standard
The Degc compiler is a multi-pass design, translating the input text to
 executable code over 8 self-contained stages.
 This design simplifies the implementation of new features, as the behavior
 of each stage can be implemented and tested separately.
\end_layout

\begin_layout Standard
The recommended approach for introducing new features is to write failing
 test cases.
 The compiler will automatically generate unimplemented feature errors,
 letting you know what files must be modified to support your feature.
\end_layout

\begin_layout Subsection
compiler::ast
\end_layout

\begin_layout Standard
The 
\emph on
ast
\emph default
 namespace contains the Abstract Syntax Tree implementation.
 The parser output consists of AST nodes, which encode the language in a
 tree structure.
\end_layout

\begin_layout Itemize

\noun on
factory
\noun default
 - An AST node factory, used by the parser rules to generate AST nodes.
\end_layout

\begin_layout Itemize

\noun on
node
\noun default
 - Contains declarations of AST node types.
\end_layout

\begin_layout Itemize

\noun on
visitor
\noun default
 - An abstract visitor interface used by later compiler stages to inspect
 the AST.
\end_layout

\begin_layout Subsection
compiler::diagnostics
\end_layout

\begin_layout Standard
The 
\emph on
diagnostics
\emph default
 namespace contains utilities and helper functions for error reporting.
\end_layout

\begin_layout Itemize

\noun on
error
\noun default
 - Container object describing a single error.
\end_layout

\begin_layout Itemize

\noun on
errorcode
\noun default
 - Names error codes.
\end_layout

\begin_layout Itemize

\noun on
errorlevel
\noun default
 - Names error levels.
\end_layout

\begin_layout Itemize

\noun on
errorlocation
\noun default
 - Container object describing the filename and position of an error.
\end_layout

\begin_layout Itemize

\noun on
report
\noun default
 - Abstract error report interface.
\end_layout

\begin_layout Itemize

\noun on
storedreport
\noun default
 - Error reporter which stores Error objects.
\end_layout

\begin_layout Itemize

\noun on
streamreport
\noun default
 - Error reporter which prints errors to a provided std::ostream&.
\end_layout

\begin_layout Subsection
compiler::grammar
\end_layout

\begin_layout Standard
The 
\emph on
grammar 
\emph default
namespace contains the parser and lexical analyzer.
\end_layout

\begin_layout Itemize

\noun on
instance
\noun default
 - Encapsulates an instance of the parser.
\end_layout

\begin_layout Itemize

\noun on
lexer.lex
\noun default
 - GNU Flex lexer rules.
\end_layout

\begin_layout Itemize

\noun on
parser.y
\noun default
 - GNU Bison parser rules.
\end_layout

\begin_layout Subsection
compiler::ir
\end_layout

\begin_layout Standard
The 
\emph on
ir
\emph default
 namespace contains helper classes for generating bytecode.
\end_layout

\begin_layout Itemize

\noun on
printer 
\noun default
- Abstract interface for a bytecode printer.
\end_layout

\begin_layout Itemize

\noun on
codeprinter
\noun default
 - Prints executable bytecode.
\end_layout

\begin_layout Itemize

\noun on
textprinter
\noun default
 - Prints human-readable text.
\end_layout

\begin_layout Itemize

\noun on
splitprinter
\noun default
 - Prints to multiple printer implementations.
\end_layout

\begin_layout Subsection
compiler::sg
\end_layout

\begin_layout Standard
The 
\emph on
sg
\emph default
 namespace contains the Semantic Graph implementation.
 The first compiler stages convert the Abstract Syntax Tree to the Semantic
 Graph data structure, which is more useful for performing semantic analysis.
\end_layout

\begin_layout Itemize

\noun on
error_helper
\noun default
 - Contains helper functions for reporting semantic errors.
\end_layout

\begin_layout Itemize

\noun on
module
\noun default
 - Records all of the symbols contained within a single module.
\end_layout

\begin_layout Itemize

\noun on
node
\noun default
 - Contains declarations of Semantic Graph node types.
\end_layout

\begin_layout Itemize

\noun on
scope_stack
\noun default
 - Contains a stack of scopes, allowing argument look-up within nested scopes.
\end_layout

\begin_layout Itemize

\noun on
scope
\noun default
 - A single scope containing symbols (e.g.
 function arguments, record members).
\end_layout

\begin_layout Itemize

\noun on
table
\noun default
 - Semantic Graph root node.
\end_layout

\begin_layout Itemize

\noun on
visitor
\noun default
 - An abstract visitor interface used by later compiler stages to inspect
 the SG.
\end_layout

\begin_layout Subsection
compiler::stages
\end_layout

\begin_layout Standard
The 
\emph on
stages
\emph default
 namespace contains the transformation rules used for translating the input
 program into the bytecode and network output.
\end_layout

\begin_layout Subsubsection
generate_ast
\end_layout

\begin_layout Standard
Constructs an Abstract Syntax Tree from an input source file.
\end_layout

\begin_layout Subsubsection
generate_sg
\end_layout

\begin_layout Standard
Constructs a basic Semantic Graph from the Abstract Syntax Tree generated
 in the previous stage.
\end_layout

\begin_layout Standard
The basic SG contains built-in types, along with user-defined modules and
 symbols, although the contents of type, function, and program symbols are
 not yet initialized.
\end_layout

\begin_layout Subsubsection
resolve_imports
\end_layout

\begin_layout Standard
Associates named imports with the actual symbol nodes generated in the previous
 stage.
\end_layout

\begin_layout Subsubsection
generate_members
\end_layout

\begin_layout Standard
Populates user-defined type symbols - records, enumerations, and function
 arguments.
\end_layout

\begin_layout Subsubsection
generate_expr
\end_layout

\begin_layout Standard
Generates expressions from the AST, replacing names with SG node references,
 and performs semantic analysis.
\end_layout

\begin_layout Subsubsection
constant_folding
\end_layout

\begin_layout Standard
Performs any possible off-line computation, converting constant expressions
 into constant values.
\end_layout

\begin_layout Subsubsection
generate_set_expr
\end_layout

\begin_layout Standard
Normalizes set filter expressions, verifying that set filters can be expressed
 as a union of orthogonal ranges.
\end_layout

\begin_layout Subsubsection
generate_code
\end_layout

\begin_layout Standard
Generates networks and bytecode for programs and functions.
\end_layout

\begin_layout Subsection
runtime::code
\end_layout

\begin_layout Standard
The 
\emph on
code
\emph default
 namespace contains data structures used to record facts about an executable
 program.
\end_layout

\begin_layout Itemize

\noun on
codebuffer
\noun default
 - Contains an executable bytecode stream.
\end_layout

\begin_layout Itemize

\noun on
codebufferreadstream
\noun default
 - Reads from a CodeBuffer at a specified offset.
\end_layout

\begin_layout Itemize

\noun on
codebufferwritestream
\noun default
 - Appends to a CodeBuffer, used by 
\noun on
compiler::ir::codeprinter
\noun default
.
\end_layout

\begin_layout Itemize

\noun on
functiontable
\noun default
 - Uniquely associates function names with a CodeBuffer offset.
\end_layout

\begin_layout Itemize

\noun on
programtable
\noun default
 - Uniquely associates program names with a program data structure.
\end_layout

\begin_layout Itemize

\noun on
recordtypetable
\noun default
 - Uniquely associates record names with an integer identifier.
\end_layout

\begin_layout Subsection
runtime::math
\end_layout

\begin_layout Standard
The 
\emph on
math
\emph default
 namespace contains utility classes used for compiling and solving programs.
\end_layout

\begin_layout Itemize

\noun on
fixed
\noun default
 - Defines a fixed-point decimal data type.
\end_layout

\begin_layout Itemize

\noun on
interval
\noun default
 - Defines an interval on a data type.
 Used by 
\noun on
set
\noun default
.
\end_layout

\begin_layout Itemize

\noun on
relation
\noun default
 - Defines the relations used by 
\noun on
set
\noun default
 to construct intervals.
\end_layout

\begin_layout Itemize

\noun on
set
\noun default
 - Defines a set on the ontology as a union of orthogonal ranges.
\end_layout

\begin_layout Subsection
runtime::solver
\end_layout

\begin_layout Standard
The 
\emph on
solver
\emph default
 namespace contains utility classes used for solving programs.
\end_layout

\begin_layout Itemize

\noun on
record
\noun default
 - Describes the contents of a single record field.
\end_layout

\begin_layout Itemize

\noun on
recordtable
\noun default
 - Abstract interface for a collection of records of a particular type.
\end_layout

\begin_layout Itemize

\noun on
linearrecordtable
\noun default
 - Implementation of RecordTable which uses linear search.
\end_layout

\begin_layout Itemize

\noun on
recordindex
\noun default
 - Collection of RecordTable instances, one for each type in the ontology.
\end_layout

\begin_layout Itemize

\noun on
network
\noun default
 - Network data structure and implementation of Edmonds-Karp algorithm.
\end_layout

\begin_layout Itemize

\noun on
program
\noun default
 - Program data structure.
\end_layout

\begin_layout Subsection
runtime::vm
\end_layout

\begin_layout Standard
The 
\emph on
vm
\emph default
 namespace contains the bytecode virtual machine implementation.
\end_layout

\begin_layout Itemize

\noun on
opcode
\noun default
 - Defines the opcodes which can be executed by the virtual machine.
\end_layout

\begin_layout Itemize

\noun on
virtualmachine
\noun default
 - The virtual machine implementation.
 Executes programs via bytecode interpretation.
\end_layout

\end_body
\end_document
